<!--
 * @Date: 2022-02-27 02:42:53
 * @LastEditors: CZH
 * @LastEditTime: 2023-01-18 15:12:29
 * @FilePath: /vue3MarkedComponent/example/assets/前端开发须知.md
-->
# 文档来源
#### [zhangyuang](https://github.com/zhangyuang)
#### [czhmisaka](https://github.com/czhmisaka)
# 一些常用的链接

[Vue文档](https://cn.vuejs.org/v2/guide/)

[AntDesign文档](https://antdv.com/docs/vue/introduce)

[阮老师的es6文档](https://es6.ruanyifeng.com/)

[前端必查手册-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)

[clip-css生成工具](https://bennettfeely.com/clippy/)


# 代码规范


## 代码风格
良好的代码风格可以保证项目的持续发展,但是保持代码风格并不应该造成开发者的心智负担。
此处我个人建议使用typescript作为项目的唯一开发语言，获得类型推断的能力可以有效的减少开发过程中的文档翻找等时间支出。

### 中文编码
在ts文件中，直接使用中文编码不会影响代码的运行稳定性，参考以下案例：
```typescript
/*
 * @Date: 2022-04-28 22:29:05
 * @LastEditors: CZH
 * @LastEditTime: 2023-01-11 18:03:39
 * @FilePath: /configforpagedemo/src/modules/userManage/PageConfigData/adminManage.tsx
 */

import {
  gridCellMaker,
  gridSizeMaker,
  cardComponentType,
  cardOnChangeType,
  gridCellTemplate,
} from "@/components/basicComponents/grid/module/dataTemplate";
import { post, get } from "@/utils/api/requests";
import {
  SearchCellStorage,
  tableCellTemplateMaker,
  searchCell,
  showCell,
  DateCell,
  actionCell
} from "@/modules/userManage/component/searchTable/searchTable";
import { btnActionTemplate, formInputType, showType, stringAnyObj } from "@/modules/userManage/types";
import { btnMaker, } from "../component/searchTable/drawerForm";
import { ElMessage, ElMessageBox } from "element-plus";
import { refreshDesktop } from "@/components/basicComponents/grid/module/cardApi";

export const adminManage = async () => {
  const 管理员判断参数 = {
    true: '是',
    false: '否'
  }

  // 管理员列表
  const 管理员列表 = new SearchCellStorage([
    tableCellTemplateMaker('用户名', 'name'),
    tableCellTemplateMaker('联系方式', 'mobile'),
    tableCellTemplateMaker('管理员', 'adminFlag', {
      ...searchCell(formInputType.select, {
        inputOptions: 管理员判断参数,
      }), ...showCell(showType.func, {
        showFunc: (data, key) => 管理员判断参数[data[key] + '']
      })
    }),
  ]);

  const 新增管理员 = btnMaker('提交', btnActionTemplate.Function, {
    icon: 'plus',
    elType: 'primary',
    function: async (that, data) => {
      console.log(data)
      if (!data.id) ElMessage.error('请选择用户')
      let res = await post('/web/usc/user/edit/admin', { id: data.id, adminFlag: true })
      if (res["message"] == "成功") {
        that.$message.success(res["message"]);
        setTimeout(() => {
          that.close();
        }, 500);
      } else {
        that.$message.danger(res["message"]);
      }
    }
  })

  const 新增管理员弹窗 = btnMaker('新增管理员', btnActionTemplate.OpenDrawer, {
    icon: 'plus',
    elType: 'primary',
    drawerProps: {
      title: '新增管理员',
      queryItemTemplate: [tableCellTemplateMaker('用户', 'id', searchCell(formInputType.searchList, {
        inputOptions: {
          multiple: false,
          remoteMethod: async (query) => {
            let res = await post('/web/usc/user/page/org', { name: query, pageSize: 20, pageNumber: 0 })
            return res.data.list.map(x => {
              return {
                value: x.id + '',
                label: x.name + '-' + x.unitNames
              }
            })
          }
        }
      }))],
      btnList: [新增管理员]
    }
  })

  const 取消管理员权限 = btnMaker('取消管理员权限',
    btnActionTemplate.Function, {
    icon: "delete",
    elType: "danger",
    function: async (that, data) => {
      ElMessageBox({
        type: "warning",
        title: `解除用户【${data.name}】的管理员权限吗`,
        callback: async (action) => {
          if (action == "confirm") {
            let res = await post("/web/usc/user/edit/admin", {
              id: data.id,
              adminFlag: false
            });
            if (res.message == "成功") {
              ElMessage.success(res.message);
              if (that.close) that.close();
              else refreshDesktop(that);
            } else ElMessage.error(res.message);
          }
        }
      })
    }
  })

  const 搜索区域操作栏 = [新增管理员弹窗];
  const 列表右侧操作栏 = tableCellTemplateMaker('操作', 'action', actionCell([取消管理员权限], {
    fixed: "right",
  }))

  管理员列表.push(列表右侧操作栏)

  return [
    gridCellMaker(
      "searchTable",
      "管理权限编辑",
      {},
      {
        name: "userManage_searchTable",
        type: cardComponentType.componentList,
      },
      {
        props: {
          defaultQuery: {},
          autoSearch: false,
          btnList: 搜索区域操作栏,
          showItemTemplate: 管理员列表.getAll(),
          searchFunc: async (query: stringAnyObj) => {
            let res = await post("/web/usc/user/page/admin", { ...query });
            return res && res.data ? res.data : [];
          },
        },
        isSettingTool: false,
      }
    )
      .setPosition(0, 0)
      .setSize(12, 8),
  ] as gridCellTemplate[];
};

```

从这个案例中，中文编码可以避免书写部分的注释，同时也不会造成稳定性上的影响。

### eslint 和 prettier 配置方案参考（vue3+tsx)
``` Typescript
/*
 * @Date: 2021-12-30 11:00:24
 * @LastEditors: CZH
 * @LastEditTime: 2023-01-03 09:20:12
 * @FilePath: /configforpagedemo/.eslintrc.js
 */
module.exports = {
  root: true,
  env: {
    node: true
  },
  globals: {
    // Ref sugar (take 2)
    $: "readonly",
    $$: "readonly",
    $ref: "readonly",
    $shallowRef: "readonly",
    $computed: "readonly",

    // index.d.ts
    // global.d.ts
    Fn: "readonly",
    PromiseFn: "readonly",
    RefType: "readonly",
    LabelValueOptions: "readonly",
    EmitType: "readonly",
    TargetContext: "readonly",
    ComponentElRef: "readonly",
    ComponentRef: "readonly",
    ElRef: "readonly",
    global: "readonly",
    ForDataType: "readonly",
    ComponentRoutes: "readonly",

    // script setup
    defineProps: "readonly",
    defineEmits: "readonly",
    defineExpose: "readonly",
    withDefaults: "readonly"
  },
  extends: [],
  parser: "vue-eslint-parser",
  parserOptions: {
    parser: "@typescript-eslint/parser",
    ecmaVersion: 2020,
    sourceType: "module",
    jsxPragma: "React",
    ecmaFeatures: {
      jsx: true
    }
  },

  overrides: [{
      files: ["*.ts", "*.vue", "*.js", "*.config.js"],
      rules: {
        "no-undef": "off"
      }
    },
    {
      files: ["*.vue"],
      parser: "vue-eslint-parser",
      parserOptions: {
        parser: "@typescript-eslint/parser",
        extraFileExtensions: [".vue"],
        ecmaVersion: "latest",
        ecmaFeatures: {
          jsx: true
        }
      },
      rules: {
        "no-undef": "off"
      }
    }
  ],

  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'prefer-const': 'off',
    'no-explicit-any': 'off',
    "@typescript-eslint/explicit-module-boundary-types": "off",
    '@typescript-eslint/ban-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/no-empty-function': 'off',
    '@typescript-eslint/no-var-requires': 'off',
    '@typescript-eslint/no-this-alias': 'off',
    "vue/no-v-html": "off",
    "vue/require-default-prop": "off",
    "vue/require-explicit-emits": "off",
    "vue/multi-word-component-names": "off",
    "@typescript-eslint/no-explicit-any": "off", // any
    "no-debugger": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off", // setup()
    "@typescript-eslint/ban-types": "off",
    "@typescript-eslint/ban-ts-comment": "off",
    "@typescript-eslint/no-empty-function": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
    "vue/html-self-closing": [
      "error",
      {
        html: {
          void: "always",
          normal: "always",
          component: "always"
        },
        svg: "always",
        math: "always"
      }
    ],
    "prettier/prettier": [
      "error",
      {
        endOfLine: "auto"
      }
    ]
  }
}
```



## 命名规范

### 变量

优先使用**驼峰命名法**
命名必须是跟需求的内容相关的词，比如说我想申明一个变量，用来表示我的学校，那么我们可以这样定义

```javascript
const mySchool = "我的学校";
const visibleForUserInfoModal = "用户信息展示框显示控制"
```

命名是复数的时候需要加s(或者使用List),比如说我想申明一个数组，表示很多人的名字，那么我们可以这样定义

```javascript
const names = new Array();
const nameList = new Array();
```

### 常量

**命名方法 : 全部大写**
**命名规范 : 使用大写字母和下划线来组合命名，下划线用以分割单词。**

### 函数

驼峰式命名，一般使用动词或者动词+名词形式
**并没有限制单词的数量!所以尽量保证函数名能够简洁直白的表达出函数的用途**

```javascript
//bad
go、nextPage、show、open、login

// good
navToLoginPage、openCarInfoDialog、getUserInfoData
```

请求数据方法，以 data 结尾

```javascript
//bad
takeData、confirmData、getList、postForm

// good
getActionListData、submitActionListData
```

针对函数内临时使用,作用域只在当前函数内的情况下,可以使用简单命名(务必确保作用域)

### 针对不同的开发环境合理的设置变量

在变量数量较多的情况下,我们需要通过优化变量的设置来保证我们的可持续化开发
合理的使用Object对象来收敛变量的范围,一般适用于页面上存在多个功能类似的变量,或者同一个模块下存在大量控制用变量:

```javascript
// 使用类似功能聚合 
// 也就是页面中存在大量功能类似的变量
const visibleControl = {
    userInfoModal:false,
    userPermisionModal:false,
    actionPermisonModal:false,
    otherInterface
}

// 依照功能模块聚合
// 一般推荐使用这种,因为在之后的compositionApi的开发思想也在于保证功能范围的闭合
// 这里使用编辑用户信息的弹窗做个示范
const userInfoModal = {
    submitFormData:{},  // userInfo编辑后数据
    originData:{},      // userInfo原始数据 - 常用与匹配是否修改
    modalVisible:false, // 弹窗控制
    checkRule:{},       // userInfo表单校验
}
```

在这里需要注意的一点是 **Vue2** 对于使用Key直接修改*Object*对象内数据的行为可能导致破坏数据映射,一般可以使用 **$set** 方案去保留数据映射.

### 页面(Views)

views文件夹下的文件命名
只有一个文件的情况下不会出现文件夹，而是直接放在 views 目录下面，如 index.vue ,尽量是名词,且使用驼峰命名法
开头的单词就是所属模块名字（workbenchIndex、workbenchList、workbenchEdit）
名字至少两个单词（good: workbenchEdit）（bad:workbench）

### Props

在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板中应该始终使用 kebab-case
**绝对禁止使用prop对父组件进行数据修改!这会导致后期使用组件和排查的时候产生混乱**

```Html
<!-- bad -->
<script>
props: {
  'greeting-text': String
}
</script>
<welcome-message greetingText="hi"></welcome-message>

<!-- good -->
<script>
props: {
  greetingText: String
}
</script>
<welcome-message greeting-text="hi"></welcome-message>
```

### 注释规范

最好给每一个多处使用过的函数/变量添加注释
案例：
```javascript
// 用于xxx的变量

/**
 * name: xxx函数
 * description: 功能释义
 * props:xxx
 * return:xxx
 */
```

### 一些常用词汇

```python
get 获取/set 设置,
add 增加/remove 删除
create 创建/destory 移除
start 启动/stop 停止
open 打开/close 关闭,
read 读取/write 写入
load 载入/save 保存,
create 创建/destroy 销毁
begin 开始/end 结束,
backup 备份/restore 恢复
import 导入/export 导出,
split 分割/merge 合并
inject 注入/extract 提取,
attach 附着/detach 脱离
bind 绑定/separate 分离,
view 查看/browse 浏览
edit 编辑/modify 修改,
select 选取/mark 标记
copy 复制/paste 粘贴,
undo 撤销/redo 重做
insert 插入/delete 移除,
add 加入/append 添加
clean 清理/clear 清除,
index 索引/sort 排序
find 查找/search 搜索,
increase 增加/decrease 减少
play 播放/pause 暂停,
launch 启动/run 运行
compile 编译/execute 执行,
debug 调试/trace 跟踪
observe 观察/listen 监听,
build 构建/publish 发布
input 输入/output 输出,
encode 编码/decode 解码
encrypt 加密/decrypt 解密,
compress 压缩/decompress 解压缩
pack 打包/unpack 解包,
parse 解析/emit 生成
connect 连接/disconnect 断开,
send 发送/receive 接收
download 下载/upload 上传,
refresh 刷新/synchronize 同步
update 更新/revert 复原,
lock 锁定/unlock 解锁
check out 签出/check in 签入,
submit 提交/commit 交付
push 推/pull 拉,
expand 展开/collapse 折叠
begin 起始/end 结束,
start 开始/finish 完成
enter 进入/exit 退出,
abort 放弃/quit 离开
obsolete 废弃/depreciate 废旧,
collect 收集/aggregate 聚集
```

## 文件结构

## 组件化开发

## 编码规范以及习惯

**良好的编码规范有利于保证代码的生命力**
具体可以参考 [Es6 编码规范](http://www.waibo.wang/bible/es6/html/24/24.6.html)
以下做简洁说明

### 使用 let const 分别定义变量和常量

### 静态字符串一律使用单引号或反引号，动态字符串使用反引号

```javascript
      // bad
  const a = 'foobar'
  const b = 'foo' + a + 'bar'

  // acceptable
  const c = `foobar`

  // good
  const a = 'foobar'
  const b = `foo${a}bar`
  const c = 'foobar'
```

## 代码审核

1. 每次开发完成的代码在合并之前需要进行代码审核
2. 提交代码审核的代码需要自行确保没有功能上的缺失
3. 项目发布之前会有简要的代码审核

**具体的开发过程可以参考Git操作和开发分支管理手册**

## 需要注释的场景

1. 各组件中重要函数或者类说明
2. 复杂的业务逻辑处理说明
3. 特殊情况的代码处理说明,对于代码中特殊用途的变量、存在临界值、函数中使用的 hack、使用了某种算法或思路等需要进行注释描述
4. 多重 if 判断语句 / switch语句
5. 对于自己设计的单独的模块务必进行明确的注释说明



# 公共组件开发和使用说明

# 一些简单的问题
## 跨域

简单介绍一下什么是跨域以及如何解决跨域

### 什么是跨域

跨域基本是每一个前端工程师开发中都会遇到的问题，跨域的基本概念和原因这里简单概括下，协议域名端口三者任一不一致都会导致跨域。需要清楚的是跨域限制是浏览器给我们的安全策略的限制，在服务端是没有该限制的。

### 如何解决跨域

大部分网络上的答案都是让后端协助来修改设置`Access-Control-Allow-Origin`,这里我们不介绍这种方式，只介绍在几乎没有后端帮助的情况下如何解决跨域

#### JSONP

使用JSONP是前端解决跨域最快的方式，但是这种方式仍然需要后端小小支持下，这里我们给一个最简单的JSONP实现方式

```js
var url = `https://api.test.com?jsoncallback=jsonpCb`
var script = document.createElement('script')
script.src = url
document.getElementsByTagName('body')[0].appendChild(script)
function jsonpCb (res) {
    console.log(`接口数据${res}`)
}
```

#### Chrome插件

[Access-Control-Allow-Origin](https://chrome.google.com/webstore/detail/allow-cors-access-control/lhobafahddgcelffkeicbaginigeejlf?hl=zh-CN)
本质是给接口的response header中添加`Access-Control-Allow-Origin: *`, 底层原理是通过Chrome提供的Api来实现

#### Node代理

大部分前端框架提供给你的proxy功能本质上都是使用了`webpack-dev-server`的proxy功能，而`webpack-dev-server`的proxy功能本质上是本地启动了一个Node服务来实现请求的转发
我们也可以自己用`egg|koa`框架来创建一个简单的本地Node服务

```js
// koa.js
const Koa = require('koa')
const router = require('koa-router')
const app = new Koa()
router.get('/api/getInfo', async (ctx) => {
    const res = await http.get('http://api.test.com/getInfo')
    ctx.body = res
})
app
  .use(router.routes())
  .use(router.allowedMethods())
app.listen(3000)

// fe.js
fetch('http://api.test.com/getInfo') 替换为 fetch(`http://localhost:3000/api/getInfo`)
```

## 纯前端下载excel

本节介绍在没有后端服务的情况下如何将数据下载为excel
使用[sheetJs](https://github.com/SheetJS/sheetjs)

```js
$ npm install xlxs // <script lang="javascript" src="dist/xlsx.full.min.js"></script>

const filename = 'file.xlsx' // 文件名称
const data = [
    {a: 1, b:2, c: 3},
    {a: 1, b:2, c: 3}
    {a: 1, b:2, c: 3}
] // 此时数据为一般接口返回的数据格式，不符合sheetJs要求，需要转换为二维数组
const dataArr = []
dataArr.push([
    'a数据',
    'b数据',
    'c数据',
]) // 第一行表头名称
data.map(item => {
    const arr = []
    for (const i in item) {
        arr.push(item[i])
    }
    dataArr.push(arr)
})
const wsName = 'Sheet1' // Excel第一个sheet的名称
const wb = XLSX.utils.book_new()
const ws = XLSX.utils.aoa_to_sheet(dataArr)
XLSX.utils.book_append_sheet(wb, ws, wsName) // 将数据添加到工作薄
XLSX.writeFile(wb, filename) // 导出Excel
```

## 开发须知

组件作为代码可复用的实现方式,我们可以在设计之初就为组件注入足够的扩展性和独立性

### 开发前

1. 需要明确组件的使用范围,接受参数,回调方式,影响范围
2. 编写文档
3. 避免重复开发组件
4. 保持低耦合,只接受必要的参数
5. 保证一定的扩展性,这个可以在设计文档的时候说明

### 开发中

1. 遵守上述命名规范
2. 保持注释
3. 保持组件独立性
4. 自我检测

### 后续维护

1. 有时间的话自己搞单元测试.....

# 前端开发小提示

本章节记录一些前端开发中的小tips欢迎补充

## 禁用export default

使用export default会导致你在混合使用cjs+esm的时候加载模块极易出现错误。详细分析文章参考
[球球你们，别再用export default了。](https://zhuanlan.zhihu.com/p/97737035)
[深入解析ES Module（二）：彻底禁用default export](https://zhuanlan.zhihu.com/p/97335917)

## 使用map代替if else

代码里出现过多的if else无疑可读性非常差

```js
// 优化前
function getRes (path) {
    if (path === '/') {
        return 'index'
    } else if (path === '/news') {
        return 'news'
    } else {
        return '404'
    }
}
// 优化后

const map = {
    '/': 'index',
    '/news': 'news'
}

function getRes (path) {
   return map[path] || '404'
}
```



## Chrome

目前最流行，最强大的浏览器，也是前端开发必备的浏览器。下面我们来介绍使用Chrome浏览器的一些小技巧。

### 快捷键

老生常谈，任何常用的应用的快捷键都必须熟练使用，玩得66的, 下面介绍常用的快捷键，再次声明本文档不是大而全的文档，Chrome快捷键组合大概有几十种，但我们只需要记住最常用的几种就行了

Chrome快捷键和前面讲到的iterm2, VS Code快捷键几乎一样，事实证明优秀的设计是每个应用都会共同遵守的

* `cmd` + `T` 打开一个新的Tab    
* `cmd` + `数字键` 快速跳转到和数字键对应的Tab， `cmd + 9` 跳转到最后一个tab    
* `cmd` + `shift` + `N` 以无痕模式打开新窗口  
* `cmd` + `w` 关闭当前窗口  
* `cmd` + `N` 打开一个新的浏览器窗口  

### 插件

Chrome的[插件商店](https://chrome.google.com/webstore/category/extensions?hl=zh-CN)的强大程度无与伦比，下面来介绍我们开发中经常用到的一些插件

* [沙拉查词](https://chrome.google.com/webstore/detail/cdonnmffkdaoajfknoeeecmchibpmkmg) 必装的插件，划词翻译功能是我目前用过的最舒服的  
* [Quick QR](https://chrome.google.com/webstore/detail/afpbjjgbdimpioenaedcjgkaigggcdpp) 必装的插件，将链接转换为二维码  
* [lighthouse](https://chrome.google.com/webstore/detail/blipmdconlkpinefehnmjammfjpmpbjk) Google官方出品，可以分析出你的网页的性能数据，以及列出可以优化的点  
* [JSON Formatter](https://chrome.google.com/webstore/detail/bcjindcccaagfpapjjmafapmmgkkhgoa) 格式化JSON文件，让你在浏览器打开JSON文件时获得更愉悦的体验  
* [React Developer Tools](https://chrome.google.com/webstore/detail/fmkadmapgofadopljbjfkapdkoienihi) 开发React应用时用的辅助工具，大部分人应该都装了  
* [Vue.js devtools](https://chrome.google.com/webstore/detail/nhdogjmejiglipccpnnnanhbledajbpd) 同上，开发Vue应用时的辅助工具  
* [Octotree](https://chrome.google.com/webstore/detail/bkhaagjahfmjljalopjnoealnfndnagc) 方便你查看github项目结构  
* [OctoLinker](https://chrome.google.com/webstore/detail/octolinker/jlmafbaeoofdegohdhinkhilhclaklkp) 查看github文件时可以一键打开引入文件的路径  
* [Allow-Control-Allow-Origin](https://chrome.google.com/webstore/detail/nlfbmbojpeacfghkpbjhddihlkkiljbi) 为不支持跨域请求的接口的响应头加Allow-Control-Allow-Origin: *  

## Node.js

本文档将会介绍我们在开发Node.js应用时会用到的一些工具

### nvm

管理Node.js版本，通过[nvm](https://github.com/nvm-sh/nvm)我们可以同时安装/切换不同的Node.js版本

#### 安装nvm

```bash
$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash
```

#### 添加环境变量

```bash
$ vim ~/.zshrc

在尾部添加以下配置
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  ## This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  ## This loads nvm bash_completion
```

#### 使用命令

```bash
$ nvm ls-remote ## 列出所有支持的Node.js版本
$ nvm ls ## 列出本地已安装的Node.js版本
$ nvm install 11.5.0 ## 安装指定的Node.js版本
$ nvm alias default 11 ## 设置默认使用的版本
```

### nrm

使用[nrm](https://github.com/Pana/nrm)可以让我们来切换不同的npm源而不用单独安装cnpm之类的库

#### 安装nrm

```bash
$ npm install -g nrm
```

#### 使用命令

```bash
$ nrm ls ## 列出当前支持切换的源
$ nrm use taobao ## 使用taobao的源作为默认的npm源
```

### 实用模块

下面来介绍一些实用的Node.js模块

#### dclone

[dclone](https://github.com/zhangyuang/dclone)用来下载某个特定的github仓库的文件夹，而不是下载整个项目，可以缩短你的下载时间

```bash
$ npm i -g dclone
$ dclone https://github.com/ykfe/egg-react-ssr/tree/dev/example/ssr-with-loadable
```

#### http-server

使用[http-server](https://www.npmjs.com/package/http-server)我们可以快速的创建一个本地http server服务，并且托管我们当前目录作为静态资源文件夹而不用特地去用Node.js框架来搭建一个静态资源服务

##### 如何使用http-server

```bash
$ npm install http-server -g ## 安装http-server模块
$ http-server . -p 8080 ## 监听8080端口，以当前目录作为静态资源目录
```

#### npx

使用npx来让我们可以方便的调用项目的依赖模块

```bash
$ npx jest ## 直接调用node_modules中的jest而不需要手动编写npm script
$ npx create-react-app app ## npx 将create-react-app下载到一个临时目录，使用以后再删除。使得你不需要全局安装
```

#### optimist

用于解析命令行参数

```js
var argv = require('optimist').argv;
 
if (argv.rif - 5 * argv.xup > 7.138) {
    console.log('Buy more riffiwobbles');
}
else {
    console.log('Sell the xupptumblers');
}
```

#### yargs 

用于开发命令行工具

![](https://raw.githubusercontent.com/yargs/yargs/master/screen.png)

#### cloc

使用cloc 快速统计某文件夹下代码的数据, 更多参考资料查看[代码统计利器 Cloc](https://www.hi-linux.com/posts/4004.html)

```bash
$ npm i -g cloc
$ cloc --exclude-dir=node_modules . --exclude-ext=json,html ## 统计文件类型，排除node_modules,排除json，html文件
```
![cloc](https://img.alicdn.com/tfs/TB1kYu2qND1gK0jSZFsXXbldVXa-1136-950.jpg)

#### promisify

[util.promisify](http://nodejs.cn/api/util.html#util_util_promisify_original)是Node.js的官方API，使用该API我们可以将callback形式的Node.js API包装为Promise的形式,只要符合最后一个参数是callback，并且callback第一个参数是错误处理的API都可以通过promisify来包装

```js
const { promisify } = require('util')
const { exec } = require('child_process')
const execWithPromise = promisify(exec)
const installServer = async () => {
    const { stdout } = await execWithPromise(`npm i -g http-server`)
}
```

#### mdv

[mdv](https://www.npmjs.com/package/mdv)是一个用来校验markdown语法的npm模块，此模块检测的语法错误类型包括七项：插入图片时是否添加Alt标签，超链接是否包含链接名称，页面内跳转时是否缺失锚点，页面内跳转的地址是否包含#，锚点是否包含#，锚点是否重复定义，json、xml语法是否解析失败。

##### 安装使用

```bash
$ npm i -g mdv
$ mdv xxx.md -d ## 检测md文件语法
$ mdv xxx.md -s ## 根据md生成html
```

##### 错误类型

- 重复链接 - `duplicatedAnchors[]`
- 锚点地址错误 - `anchorsWithHash[]`
- 空的链接 - `anchorsWithEmptyText[]`
- img标签缺少alt属性 tag - `imagesWithMissingAlt[]`
- `yaml`, `json`, `xml` or `abnf` 语法解析错误 - `nonParsingExamples[]`

### 使用 npm link 调试模块

熟练的使用npm link可以帮助我们本地调试任何开源项目，当我们的一个项目还没有发布到npmjs.com想在本地测试时，或者当我们想修改React/Vue的源码想在本地测试效果时，我们都需要使用npm link来进行测试。npm link 类似于Linux中的软链接，简单理解可以理解为一个快捷方式。使用方式：

```
$ cd vue // 进入本地clone下来的vue文件夹
$ npm link // 如果没有全局安装过vue 此时会创建全局node_modules下的一个软链接vue指向本地clone的vue入口文件
$ npm link vue // 在需要用调试vue模块的应用执行该命令会将当前应用的node_modules/vue指向全局node_modules/vue软链接
```

![](https://gw.alicdn.com/tfs/TB1iEl0XKH2gK0jSZFEXXcqMpXa-1450-876.jpg)
![](https://gw.alicdn.com/tfs/TB1QBh0XQY2gK0jSZFgXXc5OFXa-1450-860.jpg)


## Shell命令

熟练使用*nix系统的第一步便是熟练它的常用命令，大部分服务器的使用的Linux环境是没有GUI的，我们只能够通过命令来操控系统。对于前端开发来说，我们无需掌握大部分的高难度命令，只需掌握工作开发中常用的命令即可。如果不知道某个命令怎么用，最开始的时候是可以通过网络搜索来解决，稍微熟悉之后，就可以通过`man xxx`来查阅命令的手册来学习命令的各种参数。

### 文件相关命令

熟练使用*nix系统下的复制 移动命令可以帮助我们写一些小的自动化shell脚本。例如在前端构建完毕后，将构建产物移动到指定目录或者重命名

```bash
$ cp ./a.txt ../b.txt ## 将当前目录下的a.txt文件复制到上级目录并更名
$ mv ./a.txt ../b.txt ## 将当前目录下的a.txt文件移动到上级目录并更名
$ mv ./a.txt ./b.txt ## 重命名当前目录下的a.txt文件
```

#### find

使用 `find` 命令可以帮助我们查找符合要求的文件

```bash
$ find ./ -iname "*.js" ## 查找当前目录下的所有js文件, 忽略大小写
$ find ./ -size +25k  ## 查找当前目录下文件大小大于25kb的文件
```

#### ack

find的功能是比较弱的，对全文检索有心无力，ack是更好的搜索代码神器

安装

```bash
$ brew install ack 
```

然后，通过ack加关键字搜索即可。

```bash
$ ack targetCode
$ ack -i "ICE BUILD" ./node_modules
```

#### grep

使用 `grep` 命令可以帮助我们筛选符合要求的内容

```bash
$ grep "browserRouter" -i ./src/entry.tsx ## 在当前src目录下的entry.tsx文件中查找browserRouter关键字忽略大小写
```

#### awk 

通过awk命令我们可以筛选出符合要求的行或者列数据  

以:为分隔符，将password分为多列，并且提取出第一列的内容

```bash
$ cat /etc/passwd |awk -F ':' '{print $1}'
```


#### tar

通过tar命令可以将文件打包并压缩，也可以解包和解压缩，配合别的命令可以写成简单的发布脚本。比如下面的命令就是一个打包压缩和解压缩的例子，将当前文件夹下的所有文件打包并gzip压缩，然后再来一遍解压缩

```bash
tar -zcvf build.zip ./*
mkdir test
tar -xvf build.zip -C ./test
```

#### scp

打包好的文件可以通过scp来跨机器拷贝到集成调试服务器上面，比如我们本地打包好的文件是build.zip，需要拷贝到服务器上面/usr/share/nginx/html/，服务器ip是10.20.30.40，用户名是fe-deploy，就可以通过如下命令完成：
```bash
scp ./build.zip fe-deploy@10.20.30.40:/usr/share/nginx/html/build.zip
```

#### rsync

如果只是把打包好的文件推送到服务器上面，rsync会比上面先压缩再scp，再解压要简单很多。rsync就是用来同步两个目录，可以跨越网络。比如还是上面发布的例子，我们可以直接用下面的命令。`-r`是递归。`-v`是回显，都同步了哪些文件。`-z`是压缩。`--delete`是在目的目录删掉我们原目录不存在的文件。

```bash
rsync -rvz ./ fe-deploy@10.20.30.40:/usr/share/nginx/html --delete
```

### 进程相关命令

```bash
$ lsof -i:8000 ## 查看端口占用情况
$ ps ## 查看当前正在运行的进程，ps命令选项众多这里不一一介绍
$ kill -9 pid ## 根据进程pid来将进程强制退出
```

### 管道

管道可以将上一个命令的stdout输出，作为下一个命令的stdin输入。通过管道符我们可以实现一些稍微复杂的自动化的脚本功能

比如，查找当前正在运行的Node进程并提取出pid传给kill命令来退出进程。

```bash
$ ps | grep -i "node" | awk '{print $2}' | xargs kill -9 
```

### tree

大部分框架的文档都是使用tree命令来列出目录结构示例,更多功能查看[文档](https://wangchujiang.com/linux-command/c/tree.html)

```bash
$ tree -L 2 -I 'node_modules' ## 目录结构层级为2，忽略node_modules
├── app.js
├── dist
├── f.yml
├── package.json
└── src
    ├── detail
    ├── index
    └── layout
    
```

### time

time命令用于统计给定命令所花费的总时间。更多信息查看[文档](https://man.linuxde.net/time)

```bash
$ time ls
```

### ssh

有时候我们也需要登录到服务器上面，就可以通过`ssh`来登录。也可以通过配置把本地的公钥加到服务器上面，来省略输入密码的过程，详细的步骤可以搜索下，这里就不详细说了。
```bash
$ ssh fe-deploy@10.20.30.40
```



## TypeScript

TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程

### 如何编译ts文件

我们可以直接使用ts-node来执行ts文件，或者使用tsc来将ts文件编译成js文件后在执行

#### ts-node

```bash
$ npm i -g ts-node
$ npm install -g typescript
$ ts-node foo.ts
```

#### tsc

```bash
$ npm i --save-dev typescript
$ npx tsc -p ./tsconfig.json
```

### 如何调试ts文件

本章介绍使用如何vscode来调试ts文件

```json
// launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Current TS File",
            "type": "node",
            "request": "launch",
            "program": "${workspaceRoot}/node_modules/ts-node/dist/bin.js",
            "args": [
                "${relativeFile}"
            ],
            "cwd": "${workspaceRoot}",
            "protocol": "inspector",
            "env": { "TS_NODE_PROJECT": "tsconfig.base.json" } // 使用该环境变量指定具体的tsconfig文件，默认为tsconfig.json
        }
    ]
  }
```

### TypeScript 知识点收集

本章介绍一些编写TS代码中比较重要的知识点

#### 泛型

个人简单理解泛型就是让我们可以像函数一样接收一个参数来动态的设置类型，本节收集整理在泛型的使用过程中的一些高级用法

##### 泛型约束

使得Foo类型传入的对象必须包含在接口Initial的属性之中

```ts
interface Initial {
    foo:string
}

type Foo <T extends Initial> = {
    [key in keyof T]: T[key]
}

type Bar = Foo<{foo:string}>
```

##### 参数扩展

通过此方式，我们可以设置一些默认的接口参数，然后通过泛型的方式，来让调用者可以扩展默认的接口

```ts
interface Initial {
    foo:string
}

type Foo <T = {}> = T & {
    [key in keyof Initial]: Initial[key]
}

type Bar = Foo<{bar:string}>
```

##### 复合类型转Map

```ts
type Union = 'a' | 'b' | 'c'

type UnionToMap = {
    [key in Union]: string
}
```

##### Map转复合类型

```ts
type MyMap = {
    foo:string
    bar:number
}

type MapToUnion = MyMap[keyof MyMap] // string|number
```

##### 类型转换为Optional

```ts
interface Foo {
    foo:string
    bar:string
}

type Optional <T>= { [key in keyof T]?: T[key] }

type OptionalFoo = Optional<Foo>
```

##### 类型转换为readonly

```ts
interface Foo {
    foo:string
    bar:string
}

type Optional <T>= { readonly [key in keyof T]: T[key] }

type OptionalFoo = Optional<Foo>
```

##### 接收多个参数，Union转Map

```ts
type Foo<T extends keyof any, O> = { [key in T]: O}

type Size = 'small' | 'default' | 'big'

type SizeMap = Foo<Size, number>

```

##### 递归添加readonly

```ts
type DeepReadony<T> = {
    readonly [P in keyof T]: DeepReadony<T[P]>
}

interface SomeObject {
  a: {
    b: {
      c: number;
    };
  };
}

const obj: DeepReadony<SomeObject> = { a: { b: { c: 2 } } };

```


<!--
 * @Date: 2022-03-31 10:21:22
 * @LastEditors: CZH
 * @LastEditTime: 2022-03-31 14:56:18
 * @FilePath: /vue3MarkedComponent/example/assets/Utils.md
-->

## Utils

本篇文章将介绍一些实用类的小工具来帮助我们从繁琐的鼠标操作中脱离出来

### Spectatle

[Spectatle](https://www.spectacleapp.com/)一款可以让你更加轻松快速的控制窗口大小的软件。
快速实现窗口全屏/靠左/靠右/居中等展现形式, 建议快捷键设置如下。  

* `cmd` + `alt` + `enter` 全屏  
* `cmd` + `alt` + `<-` 靠左

![](https://gw.alicdn.com/tfs/TB1ESaBXG67gK0jSZFHXXa9jVXa-1224-1066.jpg)

### Dash

[Dash](https://kapeli.com/dash)是一个文档API文档浏览器，在单一窗口中可以浏览、搜索各API细节。使用效果如下图所示。

![](https://img.alicdn.com/tfs/TB1xPgeXNv1gK0jSZFFXXb0sXXa-1820-1206.png)

使用VSCode时可以在扩展中搜索Dash，点击安装即可通过 `ctrl` + `h` 快捷键查找需要的api具体说明。

### Charles

[Charles](https://www.charlesproxy.com)是一个代理服务器，简单的说法为当访问网站时，会由Charles代为获取请求相关数据，这样就达到了截取网络请求以及分析请求结果的目的。Charles是在日常工作中常用的功能包括: 代理移动端设备的请求，将远程文件代理到本地文件等。

#### 代理移动端请求

代理移动端设备的请求指的是：将移动设备的请求代理到PC的Charles服务，以此来抓包移动端设备的请求详细信息以及使得移动端设备可以打开我们的本地服务器的资源

##### 开启设置

为了可以在Charles中截取网络请求数据，首先需要将Charles设置为系统代理，即让Charles成为获取请求数据的委托代理方，具体操作为：选择菜单栏中 `proxy` -> `Mac OS X Proxy` ，使 `Mac OS X Proxy` 前出现 `✔️` 。

在charles中选择菜单栏 `proxy` -> `proxy settings` , 在弹出的对话框中填写端口号（默认为8888），勾选”enable transparent http proxying“。	

![](https://img.alicdn.com/tfs/TB1.bFMaeH2gK0jSZFEXXcqMpXa-1172-1004.png)

##### 查看本机IP

使用 `ifconfig` 查看本机在当前局域网中的IP地址

![](https://gw.alicdn.com/tfs/TB1490_ahD1gK0jSZFyXXciOVXa-1444-858.jpg)

 `enx` 代表当前的第x块网卡，当前我们只有一块网卡，故 `192.168.199.161` 是我们当前的局域网ip地址

##### 移动端开启代理设置

确保手机和电脑连接同一个无线网络，并对无线网络进行代理设置

 `WIFI` -> `HTTP代理` -> `手动` -> `填写IP以及端口号` 

<img src="https://gw.alicdn.com/tfs/TB1rXl.aeP2gK0jSZFoXXauIVXa-750-1334.jpg"  style="height:556px; width:316px; ">

连接成功后Charles会弹窗提示，选择 `allow` 。至此该移动设备的请求都会被Charles所代理，我们可以在PC端的Charles中看到移动设备所有 `http` 请求的详细信息。

##### 抓包https请求

由于https协议的请求安全系数较高，在截取此类请求数据时，需要安装证书等操作，此处单独列出https协议请求的操作步骤。

1. 在PC上安装证书。在charles中选择菜单栏 `help` -> `SSL Proxying` -> `Install Charles Root Certificate` , 安装成功后，双击安装的证书进行信任处理。

![](https://img.alicdn.com/tfs/TB16ONTabj1gK0jSZFuXXcrHpXa-1478-930.png)

2. 在Charles选择菜单栏 `proxy` -> `SSL Proxying Settings` ，通过 `add` 添加需要抓包的域名，并选中 `enable SSL Proxying ` 。至此，在PC端中即可对https请求进行抓包处理。

![](https://gw.alicdn.com/tfs/TB1MrR.aeL2gK0jSZPhXXahvXXa-1482-1102.jpg)

3. 如果要截取移动端访问的https协议的数据，在完成上述步骤后，需要重复第一个步骤，并更改为选择菜单栏 `help` -> `SSL Proxying` -> `Install Charles Root Certificate on a Mobile Device or Remote Browser` 。移动端完成无线网络配置(移动端实机测试的第四步骤)后，访问[证书地址](http://charlesproxy.com/getssl)，即可完成移动端设备安装证书的操作。至此，移动端访问https请求，就可以在charles中实时显示相关抓包信息。

#### 将远程文件代理到本地

当需要在线上环境测试展示效果，而本地程序代码不确保正确的情况下，可以将线上的文件访问地址重定向到本地的文件，从而使得线上环境真正使用的为本地需要测试的文件。

 `Map Local` 是将指定的网络请求代理到本地文件，在Charles选择菜单栏 `Tools` -> `Map Local` ，填写需要重定向的源地址以及本地的目标文件。如果网络请求较为复杂，可在请求处右键选择 `Save Response` 保存请求返回的数据到本地。

##### Map From

源文件相关配置， `protocol` 选择http或者https协议， `HOST` 为远程服务域名， `PATH` 为请求的路径， `Query` 为请求查询字符串

##### Map To

为本地文件地址，可以为单文件或者文件夹的地址

注意：如果Map From以及Map To中的数据需要区分大小写，应勾取Case-sensitive选项。

![](https://gw.alicdn.com/tfs/TB1gC1XakL0gK0jSZFtXXXQCXXa-936-838.jpg)

通过以上设置，我们在访问 `http://baidu/com/test/a.js` 时，实际访问的是 `~/Desktop/a.js` 

### 实用网站

* [can i use](https://caniuse.com/) 查看一些API的兼容性  
* [中文版的lighthouse](https://developers.google.com/speed/pagespeed/insights/) 测试网页性能
* [Autoprefixer](https://autoprefixer.github.io/) 为css加上浏览器前缀，配套webpack相关插件  
* [在线可视化正则表达式测试网站](https://regexper.com)（需要科学上网）
* [在线js编辑器](https://jsfiddle.net/)（需要科学上网）



## Vim

不多介绍，*nix系统内置的编辑器。深受众多程序员喜爱，但上手难度偏高。大部分人只会一些简单的命令，vim的强大之处以及功能是一篇文章不可能介绍完的，这里只介绍一些比较简单但是实用的功能。在远程部署机上没有GUI的时候只能使用vim，所以懂得一些vim的基本操作还是很有必要的。

### 在终端里使用vi

```bash
$ set -o vi
```

然后就可以在终端里，以vi的方式对命令进行操作，非常方便。

### 快捷键

毫无疑问，必须掌握，不过确实部分快捷键比较反人类。vim的快捷键数量众多，和Chrome一样，我们只需要记住使用最常见的就足够了。

- `:wq` 退出vim。stackoverflow每日搜索次数第一问题，如何退出vim:)  
- `i` 进入插入模式  
- `q` 进入可视模式，可以用光标来选择文本  
- `jk` 上下移动  
- `hl` 左右移动   
- `ctrl` + `b/f` 上下翻页   
- `0/$` 光标快速移动到行首／行尾  
- `/` 搜索  
- `n/N` 跳转到下一个／上一个 搜索词  
- `:s/old/new/g` 单行替换  
- `:%s/old/new/g` 全局替换  

### janus

使用vim几乎是必须要装插件的，插件屏蔽了vim的一些底层配置，来让我们使用的更加舒服。比如[NerdTree](https://github.com/scrooloose/nerdtree)这个查看当前目录文件的插件几乎是必装的。这里我们推荐直接使用[janus](https://github.com/carlhuda/janus)这个扩展包，其中内置了多种实用插件，无需我们手动去一个一个安装。

#### 安装janus

```bash
$ curl -L https://bit.ly/janus-bootstrap | bash
```

#### 使用janus

这里来说以下个人喜欢的janus的功能

- 显示行号
- 文本高亮, 搜索高亮
- 句尾显示.号
- 轻松切换多种显示方式，水平显示 or 垂直显示

展示效果

![](https://i.ibb.co/190jJWM/20190710231451.jpg)

### 插件

下面来介绍常用插件 

#### NERDTree

类似于编辑器的形式来便于你查看当前文件夹，在`~/.vimrc`中添加以下设置来通过`F2`启动NERDTree

```bash
$ vim ~/.vimrc

25 map <F2> :NERDTreeToggle<CR>
```

在当前文件使用`F2`或者`:n`来切换为NERDTree显示模式，或者直接使用`vim`来打开一个文件夹

![](https://i.ibb.co/3zh603d/20190710231845.jpg)

快捷键

- `ctrl` + `w` + `h/l` 光标在左／右窗口互相切换  
- `ctrl` + `w` + `w` 光标自动切换  
- `o/go` 在当前tab打开文件, 是否跳到该窗口  
- `t` 在新Tab打开文件  


## VS Code

VS Code 毫无疑问是目前最强大的编辑器，没有之一，凭借自身丰富的插件体系以及优秀的断点调试能力迅速成为最火热的编辑器。

### 安装 VS Code

这个不多介绍，直接去[官网](https://code.visualstudio.com/)下载安装包安装

### code 命令

打开 VS Code，打开控制面板（⇧⌘P）, 输入 `shell command` ，在提示里看到 `Shell Command: Install "code" command in PATH`，运行它就可以了。

然后，在终端里，通过 `code .` 或 `code xx` 直接打开目录或文件。

### 快捷键

熟练使用 VS Code 快捷键是必备技能

#### 左边栏快捷键

`cmd + k, cmd + s` -> 点击右上角工具栏第二个按钮(打开键盘快捷方式(JSON))-> `keybinds.json`

添加以下配置

```json
({
  "key": "cmd+1",
  "command": "workbench.view.explorer"
},
{
  "key": "cmd+2",
  "command": "workbench.view.search"
},
{
  "key": "cmd+3",
  "command": "workbench.view.scm"
},
{
  "key": "cmd+4",
  "command": "workbench.view.debug"
},
{
  "key": "cmd+5",
  "command": "workbench.view.extensions"
})
```

添加完毕后我们可以通过 cmd + 数字键的组合方式来快速切换左边栏

#### 其他快捷键

以下介绍实际使用 VS Code 中经常需要用到的快捷键

- `cmd + p` 根据关键字快速打开一个文件
- `cmd + ,` 打开 VS Code 配置项
- `cmd + d` 快速选取多个相同的内容块
- `option + shift + 鼠标左键` 让光标多行选取
- `cmd + shift + h` 全局替换内容

### VSCode 设置

这里附上个人的 VSCode 设置，契合绝大多数前端开发的需求，并且忽略不必要的设置防止 VSCode CPU 占用过高

```json
{
  "explorer.confirmDelete": false,
  "emmet.triggerExpansionOnTab": true,
  "editor.tabSize": 4,
  "window.zoomLevel": -1,
  "stylelint.autoFixOnSave": true,
  "standard.autoFixOnSave": true,
  "javascript.updateImportsOnFileMove.enabled": "always",
  "gitlens.advanced.messages": {
    "suppressShowKeyBindingsNotice": true
  },
  "files.associations": {
    "*.wpy": "vue",
    "*.html": "html"
  },
  "editor.renderControlCharacters": true,
  "emmet.syntaxProfiles": {
    "vue-html": "html",
    "vue": "html"
  },
  "emmet.includeLanguages": {
    "javascript": "javascriptreact",
    "wxml": "html"
  },
  "prettier.semi": false,
  "prettier.singleQuote": true,
  "typescript.updateImportsOnFileMove.enabled": "always",
  "search.followSymlinks": false,
  "files.exclude": {
    // 是否显示这些文件(夹)
    "**/.git": true,
    "**/.svn": true,
    "**/.hg": true,
    "**/CVS": true,
    "**/.DS_Store": true,
    "**/tmp": true,
    // "**/node_modules": true,
    "**/bower_components": true
    // "**/dist": true
  },
  "search.exclude": {
    // 搜索的时候排除的文件夹，视情况开启
    // "**/node_modules": false,
  },
  "files.watcherExclude": {
    "**/.git/objects/**": true,
    "**/.git/subtree-cache/**": true,
    "**/node_modules/**": true,
    "**/tmp/**": true,
    "**/bower_components/**": true,
    "**/dist/**": true
  },
  "explorer.confirmDragAndDrop": false,
  "javascript.implicitProjectConfig.experimentalDecorators": true,
  "workbench.colorTheme": "One Dark Pro",
  "workbench.iconTheme": "vscode-icons",
  "vsicons.dontShowNewVersionMessage": true,
  "workbench.settings.editor": "json"
}
```

### 插件
在这里我们介绍前端开发中需要经常用到的一些插件,很多插件的功能VSCode已经内置了，我们安装之前需要查询一下相关资料不要重复安装使得臃肿

- `Code Spell Checker` 帮助我们检查名词的拼写
- `GitLens` 展示该代码块的 commit 信息
- `vscode-icons` 为不同的文件设置不同的 ICON
- `Markdown Preview` 预览 md 文件
- `StandardJS` JavaScript 代码规范配套的 VS Code 插件，下面我们会介绍为什么使用 standardjs 而不是 eslint
- `stylelint-plus` 配合"extends": "stylelint-config-standard"，所有的规范都按 standard 的来
- `React Standard Style` 同上，在 React 组件中使用 standardjs 代码规范
- `Minify` 自动生成经过 uglify 后的文件

### 主题

推荐使用`One Dark Pro`配合`vscode-icons`更佳
安装后 setting 添加如下配置开启

```json
"workbench.colorTheme": "One Dark Pro",
"workbench.iconTheme": "vscode-icons"
```



## 开发和需求
·
*可以尝试对照,但也没必要完全照搬*

### 面对需求时需要考虑的一些问题

每次接收到项目需求的时候,作为一名开发人员,应该在第一时间获取以下信息:

```yi
1. 这个需求的目的是什么,是为了解决什么问题,当下产品提供的方案是否为最优解?
2. 这个需求会涉及到的影响范围,以及一些可能导致的修改和冲突
3. 如果按照计划实施,需要采用什么技术,这些技术对项目未来的发展的影响
4. 未来如果要删除这个功能的话,会有什么样子的影响(这点非必需)
```

对于每一个有志于长期维护项目的开发人员而言,在需求落地之前的思考可以保证未来项目的健康发展
**如果在思考上述问题的时候发现有一些无法解决的困难点,或者是不理解的地方,绝对不要上手开干,应该第一时间提出沟通.**
并且在沟通完成(或者说在你的脑海里已经存在了完整的开发计划的时候)需要书面记录下你的想法,并及时存入当前版本的需求对应的文档存放处(如果有的话,没有的话就自己建一个....)

### 开发的过程

保持对代码质量的要求,具体可以按照本文对照
及时commit确定工作流程
使用辅助工具记录工作进程 (夹带一下私货: [tasklist](http://task.czht.top) 点击即可访问,会有一点小卡,或者需要多刷新几次)
及时同步自己的工作进度,这有利于我们在一个需求结束的时候看到自己真正的工作量(毕竟日常临时加需求,或者需要修复历史bug)




## 算法

具有良好的数据结构和算法知识是每一个高级程序员的必备技能。本篇文章介绍对于前端工程师来说如何学习算法。

对于科班与非科班最大的区别来说就是对计算机底层数据结构以及算法的理解。但如果科班同学对专业课的学习并不是很好，那么在这一方面对比非科班的同学来说并没有什么优势。而对于非科班的同学来说，如果能够掌握良好的数据结构和算法基础，对职业生涯的发展具有很大的帮助

### 初始准备

算法的底层是数据结构，个人认为学习数据结构最大的目的并不是为了学会它，而是能够知道不同的数据结构出现的目的和适用场景。例如链表和数组的区别，什么时候该用树，该用什么树。这一点才是最重要的，最关键的是不能为了学而学，否则非常容易遗忘

### 学习材料

个人推荐一些图文结合的书籍，比起纯文字和代码的书籍更易于理解

[大话数据结构](https://book.douban.com/subject/6424904/)
[算法图解](https://book.douban.com/subject/26979890/)

#### 在线课程

[数据结构-浙江大学](https://www.bilibili.com/video/av18586085?from=search&seid=15275956372728133584)  
[清华大学-邓俊辉MOOC数据结构与算法全套](https://www.bilibili.com/video/av49361421?from=search&seid=2756779141930403558)

#### 文章

[动态规划](https://zhuanlan.zhihu.com/p/91582909)
[背包问题](https://zhuanlan.zhihu.com/p/93857890)

### 网站

[leetcode](https://leetcode-cn.com/)
[算法可视化](https://visualgo.net/zh)



## 断点调试

1小时开发应用，6小时在debug。是否迅速的找出代码中的bug是决定开发效率的关键因素。大部分人在调试应用时还是用传统的 `console.log` 的方式，这种方式只适用于比较简单的应用，一旦应用改的复杂程度上升，这种方式无疑是低效的。使用断点进行debug是我们日常开发中必须要掌握的技巧，比起 `console.log` 更加的高效。如何调试ts文件请看[本章节](http://fe.surge.sh/guide/Ts.html#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95ts%E6%96%87%E4%BB%B6)

### 调试类型

针对不同的场景不同的应用，开启断点调试的方法也不一样。目前主要分为

* 本地调试Launch Program 简单说，就是直接执行，上文最简单的断点调试都属于这种模式
* 远程调试Attach to Process 简单说，是调试某个已启动的线程, 常见的场景就是调试启动的http-server

下面让我们先来介绍一下大部分场景下如何开启使用本地调试，远程调试方式我们着重介绍在VS Code中如何调试

#### node-debug

已废弃被 `node inspect` 代替，不多介绍

#### node-inspect

使用Node.js自带的inspect功能来开启断点调试

##### 使用方式

``` js
// break.js
const foo = 1
const bar = foo + 1
debugger // 功能类似于浏览器中的断点
console.log(bar)
```

``` 
$ node inspect break.js
```

此时会显示debug界面

![](https://img.alicdn.com/tfs/TB12k.CcAY2gK0jSZFgXXc5OFXa-1134-856.jpg)

##### 用法

显示debug界面后，我们通过键盘来进行不同的操作，这里我们介绍最常用的几项操作

* n 单步执行
* c 继续执行，即跳到下一个断点
* s 单步调试 点击后进入到当前方法的内部调试
* o 单步跳出 跳出当前调试的方法，与单步调试对应
* repl 进入repl(交互解释器)环境，此时可以查看某一个变量的值

##### 总结

此方法过于繁琐低效，以了解为主，知道有这种调试方法即可。在一些远程服务器上，我们有时候会用到该方法来进行调试

#### Chrome + node --inspect

借助Chrome的开发工具让我们可以在Chrome中进行断点调试

##### 使用方式

```bash
$ node --inspect break.js ## 启用debug
$ node --inspect-brk break.js ## 启用debug并在第一行暂停，即默认第一行设置了断点，建议使用这种方式来启动
```

打开 `chrome://inspect/#devices` , 进入到熟悉的界面，此时是 `远程调试` 模式

![](https://img.alicdn.com/tfs/TB17cIHcBv0gK0jSZKbXXbK2FXa-1346-624.png)
![](https://img.alicdn.com/tfs/TB10VoIcxv1gK0jSZFFXXb0sXXa-1514-534.png)

##### 总结

此种方式比较常见，我们经常会在Chrome中进行debug，Chrome的调试功能也是无比强大

#### 借助 VS Code

借助目前的前端开发第一工具，我们可以很方便的来进行断点调试

##### 本地调试

 `cmd + 4` 打开调试菜单栏，选择 `添加配置` -> `启动程序` 

![](https://img.alicdn.com/tfs/TB1e8sMcrH1gK0jSZFwXXc7aXXa-1364-668.png)
生成如下调试配置

``` json
{
    "version": "0.2.0",
    "configurations": [{
        "type": "node",
        "request": "launch",
        "name": "Launch Program",
        "program": "${workspaceFolder}/break.js", // 选择工作目录下的break.js
        // "program": "${file}" 使用变量来获取当前打开的文件

    }]
}
```

按 `F5` 启动调试，出现熟悉的界面

![](https://img.alicdn.com/tfs/TB17pkOcuH2gK0jSZJnXXaT1FXa-1002-346.png)

##### 远程调试

这里我们以express应用为例，我们在本地新建项目并且启动服务

``` bash
$ npm install express-generator -g
$ express --view=pug myapp
$ cd myapp
$ npm i
$ npm start
```

通过以上命令，我们新建了一个express应用并且启动。点击齿轮按钮，打开launch.json

![](https://gw.alicdn.com/tfs/TB1iKQHXxv1gK0jSZFFXXb0sXXa-1734-628.png)

点击绿色箭头，选择添加配置，选择附加到进程选项

![](https://gw.alicdn.com/tfs/TB1hUEHXrj1gK0jSZFuXXcrHpXa-1054-716.png)

按 `F5` 启动debug，选择第一个进程

![](https://gw.alicdn.com/tfs/TB1kkIGXAT2gK0jSZFkXXcIQFXa-1438-662.jpg)

浏览器中访问 `http://localhost:3000` VS Code就能够检测到触发断点，接下来就是我们熟悉的界面

![](https://gw.alicdn.com/tfs/TB1yHgIXrr1gK0jSZFDXXb9yVXa-1122-436.jpg)

#### 断点调试类型

这里说一下从左到右我们的断点调试类型分为4种

* 继续调试 点击后代码会执行到下一个断点所在位置，如果没有下一个断点，则认为该次请求执行完毕
* 单步跳过 点击后会跳到当前代码下一行继续执行，不会进入到方法内部
* 单步调试 点击后进入到当前方法的内部调试，例如在res.render这一行中执行单步调试，会进入到res.render方法内部进行调试
* 单步跳出 跳出当前调试的方法，与单步调试对应

### 总结

我们介绍了本地调试与远程调试两种场景，以及几种开启断点调试的方式，以上几种方式以了解为主，建议熟练掌握一种VS Code中如何使用断点调试的方式即可, 需要了解每个配置项的含义。
如果想要更进一步详细的了解debug的原理，可以查看[node-debug-tutorial](https://i5ting.github.io/node-debug-tutorial/#1)


## 终端

本篇将会介绍 zsh 这个 shell 的强大之处以及 iterm2 这个强大的现代化终端，将两个工具结合使用即酷炫又实用。  
注：本文只会介绍实际开发中使用频率比较高的用法，该工具的强大功能并未全部介绍完。如有兴趣可查阅官方文档继续学习。

### iterm2

> iterm2 取代了默认的 Terminal，它将带给你现代化的体验以及任何你想要的功能

#### 安装 iterm2

这里我们直接去[官网](https://www.iterm2.com/)进行 download

#### 快捷键

熟练使用快捷键是程序员的基本操守

##### 唤醒热键

给终端加一个快速唤醒/隐藏的快捷键是必须要做的，否则用鼠标找到终端的快捷方式再打开这种做法不仅慢而且逼格低，设置方式
 `iterm2` -> `Preferences` -> `Keys` -> `Hotkey` 

![](https://gw.alicdn.com/tfs/TB1AHfOXvb2gK0jSZK9XXaEgFXa-1920-1048.jpg)

这里我们建议使用 `option` + `space` 组合键来唤醒/隐藏终端

##### 其他快捷键

以下快捷键与 chrome 快捷键类似，必须熟练使用

- `ctrl` + `a/e` 快速切换到当前正在输入的文本的头部／尾部
- `ctrl` + `u` 清空当前输入
- `cmd` + `T` 打开一个新的 iterm2 Tab
- `cmd` + `方向键` 左右切换 Tab
- `cmd` + `D` 分屏
- `cmd` + `K` 清屏
- `cmd` + `N` 打开一个新的 iterm2 窗口

##### 透明度

个人喜好这里建议给 iterm2 配置一个透明度，看起来体验感舒适很多
 `iterm2` -> `Preferences` -> `Profiles` -> `Window` -> `Transparency` 

效果如下

![](https://gw.alicdn.com/tfs/TB1Fm_RXuH2gK0jSZJnXXaT1FXa-1452-986.jpg)

### zsh

> Unix shell，一种壳层与命令行界面，是 UNIX 操作系统下传统的用户和计算机的交互界面。第一个用户直接输入命令来执行各种各样的任务。
> 普通意义上的 shell 就是可以接受用户输入命令的程序。它之所以被称作 shell 是因为它隐藏了操作系统低层的细节。同样的 Unix 下的图形用户界面 GNOME 和 KDE，有时也被叫做“虚拟 shell”或“图形 shell”。

目前常见的 shell 有 bash、sh、csh，ksh 等, 这里我们介绍 shell 中的极品 zsh。
zsh 的强大之处随便列举就有以下几点，色彩高亮，命令提示，智能补全等等，下面我们会详细介绍
这么牛逼的东西安装起来自然是及其麻烦的，好在已经有大神帮我们做了一个一键安装 zsh 的脚本[oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)

#### 安装 zsh

使用 curl 来安装

```bash
$ sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

#### 配置主题

默认的 zsh 主题是非常丑并且展示的信息也很少的，这里 zsh 提供了多种主题供我们直接使用，当然你可以根据自己的喜欢来编写一个主题，这里我们使用 ys 这个主题。设置方式

```bash
$ vim ~/.zshrc ## 打开zsh配置文件
10 ZSH_THEME = "ys" ## 在第10行设置当前主题为ys
$ source ~/.zshrc ## 重新执行一遍zsh配置文件
```

![](https://gw.alicdn.com/tfs/TB1OxHTXAH0gK0jSZPiXXavapXa-1442-870.jpg)

#### 插件

zsh 提供了插件功能，我们可以通过插件来实现更加强大的功能

##### autojump 插件

必装插件没有之一，可以让你在任意目录之间进行跳转

```bash
$ brew install autojump
$ vim ~/.zshrc

61 plugins = (
62  git 
63  autojump 
64 )

$ source ~/.zshrc
```

###### 使用 autojump

 `j` + `目录缩写` 快速去到你曾经进入过的目录

autojump 会自动对你进入过的目录进行记录并且定义权重，使用 j 命令可以迅速进入目录

```bash
$ j hub ## 等价于 cd ~/workspace/github
$ j hub ## 如果当前目录不对，可以重复执行该命令，会自动根据权重依次匹配
$ d ## 会列出你曾经进入过的目录，输入前面的序号可以直接进入该目录
```

##### [git 插件](https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/git)

git 插件也是必装的插件，它提供了百余个 alias 来简化你的 git 命令，alias 列表可访问插件链接查看。以下几种是会被经常使用的命令，你也可以在.zshrc 中额外添加喜好的 alias

```bash
$ g ## 等价于git
$ ga ## 等价于git add
$ gcmsg "" ## 等价于git commit -m ""
$ gco ## 等价与git checkout
$ gb ## 等价于git branch
```

##### zsh-syntax-highlighting

既然 zsh 都已经安排上了，那 zsh 可用命令的高亮显示自然是不能落下，借助[zsh-syntax-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md) 来实现命令高亮

###### Preview

使用前：

![zsh-syntax-highlighting 使用前](https://img.alicdn.com/tfs/TB1F_iCb4D1gK0jSZFsXXbldVXa-404-62.png)

使用后：

![zsh-syntax-highlighting 使用后](https://img.alicdn.com/tfs/TB1H45BbW67gK0jSZFHXXa9jVXa-386-54.png)

##### zsh-autosuggestions

它能够根据你的命令历史记录即时提示，个人对它的喜爱程度仅次于 autojump。BTW，每次用同事的电脑我都会想吐槽，还不是因为他没安装 [zsh-autosuggestions](https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md) 😏

###### Preview

<a href="https://asciinema.org/a/37390" target="_blank"><img src="https://asciinema.org/a/37390.png" width="400" /></a>

##### last-working-dir

last-working-dir 插件，可以记录上一次退出命令行时候的所在路径，并且在下一次启动命令行的时候自动恢复到上一次所在的路径。这一切不需要我们进行任何操作，全部都是自动完成的

###### Preview

![last-working-dir 示例](https://img.alicdn.com/tfs/TB1poGSb4D1gK0jSZFKXXcJrVXa-1764-1408.jpg)

##### [web-search](https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/web-search)

web-search 集成了程序猿可能会用到的大部分的搜索引擎，在 iterm 中键入 `${搜索引擎} ${搜索关键词}` ，他可以直接打开对应的网页，缩短了你的搜索路径

例如，输入 `google javascript` ，它会在我的浏览器中直接打开 https://www.google.com/search?q=javascript

web-search 常用的搜索引擎如下:

 - google
 - github
 - baidu
 - stackoverflow

#### 进入目录

无需输入 `cd` 命令  
输入 `~` 等价于 `cd ～` 

#### 路径补全

\*nix 下的其他 shell 默认可以通过 tab 来实现路径补全，但是功能比起 zsh 的路径补全简直是太简单了。这里我们举一个例子
 `cd /u/l/b` 按下 tab 键自动帮你补全为 `cd /usr/local/bin/` 

### 日常工作顺序

这一套操作是本人日常使用的最频繁的操作，必须要熟练使用一气呵成。

`alt + space` （唤醒iterm2） + `cmd + T` (建立新的iterm2窗口) + `j hub `(使用autojump的j命令快速跳转到github目录 ) + `code .` (在vscode打开) +  `spectatle`( cmd + alt + enter = 窗口全屏)

